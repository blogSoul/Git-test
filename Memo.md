2020=02-14

python return값에 함수 가능?

호이스팅은 끌어올려 졌다고 해서 얘기해줍니다.

Number a = function(){
   console.log('asdf');
}; 가능?

렉시컬은 정적이다라는 말이다.

[[Scope]] 라는 리스트 부분을 보면 알 수 있다.

실행 컨텍스트가 어떻게 이루어져 있는지 한번 확인해보기

라이브러리 프레임워크 프로그램 차이점 찾기

라이브러리 = 부품(기능과 구조)상자
모듈 = 부품(기능과 구조)
서브루틴 = 기능

라이브러리 [ library ] :
컴퓨터 이용의 효율화를 꾀하기 위해서 이용자가 필요에 따라서 사용하는 표준화된 프로그램 및 서브루틴의 모임을 말한다.
이들의 제공형태는 유저 프로그램의 속에서 서브루틴으로서 사용되는 서브모듈형과 일련의 처리가 라이브러리의 속에서 완결(完結)하는 패킷형으로 크게 나누어지는데 이것을 달리 프로그램 라이브러리라고도 한다.

서브루틴 [ Subroutine ] :
어떤 하나의 종합된 기능을 가지는 명령의 모임을 루틴이라고 하며, 이것에는 메인 루틴과 서브루틴이 있다. 메인 루틴이란 프로그램의 골격이 되는 루틴이고, 서브루틴이란 프로그램속에서 항상 반복 사용되는 부분적 프로그램이며, 그자신이 독립하여 사용되는 경우는 없고 메인 루틴과 결부되어서 기능을 다하는 일련의 프로그램을 말한다.

모듈 [ module ] :
⑴ 이미 알고 있는 특성을 갖는 기능 단위로서 부품 집합이고, 그대로 모듈」이라고 해석된다. 하드웨어에서는 메모리 보드나 각종 인터페이스 보드, 보조 입출력 장치(auxiliary input/output devices), 다중 중앙 처리 장치(multi-CPU)처럼 기능 단위로 되어 있기 때문에 용이하게 교환할 수 있도록 된 구조를 말한다. 소프트웨어에서도 하드웨어와 마찬가지로 하나로 일괄되어 다른 프로그램으로도 재이용(reusable)할 수 있는 형으로 되어 있는 것을 말하며, 복수(複數)의 모듈을 취급하기 쉽도록 하나로 일괄시킨 것을 라이브러리(library)라고 한다. 이와 같이 블록화, 모듈화하여 프로그램을 작성해두면 프로그램의 명세에 변경이 있어도 관계가 있는 모듈의 변경만으로 끝나고, 프로그램 개발의 생산성이 향상된다.
⑵ 컴 파일러(compiler)의 실행에 따라 얻어진 출력으로, 연결기(linker)의 입력이 되는 중간 프로그램을 목적 모듈(object module)이라고 한다. 
복수의 제어 세션(session)과 외부 심벌(external symbols)표로 구성되어 있다. 연결기의 실행에 따라 얻어진 실행 모듈을 로드 모듈(load module)이라고 한다.

[주] 수속(절차)이나 데이터의 선언으로부터 이루어진 언어 구성 요소이고, 다른 구성 요소와 상호적으로 작용할 수 있는 것. 예를 들면, Ada의 패키지, FORTRAN의 프로그램 단위, PL/I의 외부 절차.

C#프로그래밍

클래스<변수> : 컬렉션 프레임웤
모든 탬플릿은 <>를 지원해준다. 
약어, 용어는 외워라!
이벤트를 처리해주는 코드를 event handler
이벤트 동적 연결 : 이벤트 메서드를 연결해야 한다
C#은 포로그램의 강건성이 필요해서 exception handling을 구현했다.
상속에서는 부모는 모든 자식으로 캐스팅 가능
Button self(이벤트를 발생한 객체로 활용 된다) = (Button)sender
(this,Form1 자신을 생략)FormClosed += Form1_FormClosed로 파생된다.
interval 1000 = 1초

class의 멤버를 재사용하는 방법으로 상속
class의 계층구조를 효율적으로 이용하는 방법 중에 하나가 다향성
객체를 만들면 object를 상속 받고 기본 특징을 미리 상속 받는다.
다형성을 얻으려면 상속 구조를 가져야 한다.
부모 클래스의 객체이지만 자식 클래슬 캐스팅을 하면 자식 클래스를 만들어진다.
만약 쓰려면, 객체를 생성할 수 있어야 한다. 

생성자에는 기본 생성자와 파라미터 생성자가 존재한다.
public chlid(int a):base(a=>값을 넣어준다.){
}

정통집

메소드를 abstract하면 상속하면 구현해내야 한다. 
abstract는 virtual을 사용하지 않는다.
abstract는 메모리를 할당 받지 않는다.

인터페이스란?
하나의 시스템을 구성하는 2개의 구성 요소(하드웨어, 소프트웨어) 또는 2개의 시스템이 상호작용할 수 있도록 접속되는 경계(boundary), 이 경계에서 상호 접속하기 위한 하드웨어, 소프트웨어, 조건, 규약 등을 포괄적으로 가리키는 말
자바에서 인터페이스는 여러가지 역할로 사용한다.

개발자 사이의 코드 규약을 정한다.
여러 구현체에서 공통적인 부분을 추상화한다.(다형성)
먼저 자바에서 인터페이스의 기본 개념을 알아보자.

자바 인터페이스는 기본적으로 추상메서드의 모음이다. 추상메서드는 아래와 같이 구현부가 없는 메서드를 말한다.
구현부가 없으므로 인터페이스를 만든다면 반드시 구현하는 클래스를 만들어야 하며, 인터페이스를 구현하기로 한 클래스는 반드시 인터페이스에 명시되어 있는 추상메서드들을 모두 구현해야 한다. 만약 이를 구현하지 않으면 컴파일 에러가 발생한다.
인터페이스는 구현과 상속을 모두 할 수 있다.

인터페이스를 사용하는 구체 클래스는 해당 인터페이스를 구현해야한다.
인터페이스 사이에는 상속을 할 수 있다.
인터페이스를 사용하면 다중 상속이 가능하다. 인터페이스 사이에서도, 구체 클래스에서도 여러 인터페이스를 구현 및 상속할 수 있다.

.4 프로세스간 통신(IPC, InterProcess Communication)
 1) 프로세스간 통신(IPC)란?
   - 프로세스들 간에 데이터 및 정보를 주고받기 위한 메커니즘을 말한다.
   - 커널에서 IPC를 위한 도구를 제공하며, 시스템 콜의 형태로 프로세스에게 제공된다.

 2) 프로세스간 통신의 필요성
   - 운영체제 내에서 실행되는 프로세스들은 독립적(independent)이거나 협력적(cooperative)인 프로세스들 일 수 있다.
   - 프로세스 협력 모델(cooperating process model)을 구현하기 위해 IPC가 반드시 필요하다.
  (1) 독립적인 프로세스(independent process)
   - 시스템에서 실행 중인 다른 프로세스들에게 영향을 주거나 받지 않는 프로세스
  (2) 협력적인 프로세스(cooperative process)
   - 시스템에서 실행 중인 다른 프로세스들에게 영향을 주거나 받는 프로세스
* 프로세스간 통신(IPC)에는 크게 두 가지 모델이 있다.
 1) 공유 메모리(Shared Memory) 모델
 2) 메시지 전달(Message Passing) 모델
3.4.1 공유 메모리(Shared Memory)
 1) 공유 메모리 모델의 특징
   - 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며, 공유한 메모리 영역에 읽기/쓰기를 통해서 통신을 수행한다. (Read and Write)
   - 공유 메모리가 설정되면, 그 이후의 통신은 커널의 관여 없이 진행 가능하다.

 2) 공유 메모리 모델의 장점
   - 커널의 관여 없이 메모리를 직접 사용하여 IPC 속도가 빠르다.
   - 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.

 3) 공유 메모리 모델의 단점
   - 구현하기 어렵다는 단점이 있다.

 4) 컨텍스트 스위칭 관점
   - 공유 메모리 모델에서의 IPC는 해당 프로세스가 CPU를 사용하는 행위이다. 
   - 즉, IPC를 많이 한다고 컨텍스트 스위칭 많이 일어나지 않는다.

 5) 동기화 관점
   - 메모리 영역에 대한 동시적인 접근을 제어하기 위한 방법이 필요하다.
   - 커널이 동기화를 제공하지 않으며, 부가적인 방법이 필요하다.
   - 접근 제어 방식은 locking이나 세마포어(semaphore) 등이 있다.

 6) 공유 메모리 모델의 활용의 예 : 데이터베이스
 7) 공유 메모리 모델의 구현 IPC : 공유 메모리(Shared Memory)
   - 모델과 구현의 이름이 같다.

공유 메모리
 8) 버퍼(Buffer)
   - 협력적인 프로세스의 예로, 생산자-소비자 문제를 들 수 있다.
   - 생산자-소비자 문제에 대한 하나의 해결책은, 공유 메모리(Shared memory)를 사용하는 것이며, 이 때 생산자가 정보를 채워 넣을 수 있고 소비자가 정보를 소모할 수 있는 버퍼(Buffer)가 반드시 사용 가능해야 한다.
* 버퍼는 크기에 따라 세 가지 유형으로 나눠볼 수 있다.
1) Zero capacity
- no buffering
- 저장할 수 있는 메시지의 개수는 0개이다.
- 송신자는 수신자가 메시지를 받을 때까지 대기(block)해야 한다.

2) 유한 버퍼(Bounded capacity)
- automatic buffering
- 저장할 수 있는 메시지의 개수는 n개이다.
- 버퍼가 가득 차 있지 않을 때에는, 송신자는 메시지를 보내고 대기할 필요가 없다.
- 버퍼가 가득 차 있는 경우라면, 송신자는 버퍼에 빈 공간이 생길 때까지 대기해야 한다.

3) 무한 버퍼(Unbounded capacity)
- automatic buffering
- 저장할 수 있는 메시지의 개수가 무한 개이다.
- 버퍼가 가득 찰 일이 없기 때문에, 모든 경우에 송신자는 대기할 필요가 없다.
3.4.2 메시지 전달(message passing)
 1) 메시지 전달 모델의 특징
   - 커널을 경유하여 고정길이 메시지, 가변길이 메시지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링한다. (Send and Receive)
   - 프로세스간 메모리 공유 없이 동작이 가능하다.

 2) 메시지 전달 모델의 장점
   - 구현하기에 간단하여 사용하기 편리하다.

 3) 메시지 전달 모델의 단점
   - 커널을 경유하므로, 속도가 느리다.

 4) 컨텍스트 스위칭 관점
   - 메시지 전달 모델에서의 IPC는 해당 프로세스 입장에서 일종의 입출력(I/O)로 볼 수 있다.
   - 즉, IPC를 하면 할수록 컨텍스트 스위칭이 많이 일어난다.
   => 예를 들어, send하고 상대방이 받을 때까지 기다려야 하며, 이 때 컨텍스트 스위칭이 발생한다.
   => 마찬가지로, receive하면 상대방이 보낼 때까지 기다려야 하며, 이 때 컨텍스트 스위칭이 발생한다.

 5) 동기화 관점
   - send와 receive와 같은 연산에 대해서는 커널이 동기화를 제공한다.
   - send와 receive를 수행할 때에 프로그램은 동기화에 대한 고려 없이 사용할 수 있다.
 
 6) 메시지 전달 모델 활용의 예 : 서버-클라이언트 방식의 통신
 7) 메시지 전달 모델의 구현 IPC : PIPE, Message Queue, Socket , Signal, ...
 
 1. 병렬성 측면에서 멀티프로세싱과 멀티프로세싱을 설명하고, 멀티프로세싱일 경우 각 프로세서 내에서의 메모리의 효율적인 운영방안에 대해 제시하시오.
A : 하나의 메모리 안에 여러 프로그램을 가지고 있고 의사병렬성을 가지고 있습니다. 멀티 프로세싱은 여러개의 멀티 프로세서가 존재하는 것을 의미합니다. 서로 다른 프로세서가 하나의 프로그램을 사용할 수 있기 때문에 공유 방안이 필요하고, 서로 다른 프로세서가 서로 다른 프로그램을 실행시키면 보호 방안이 필요합니다.

2. 워드 프로세스 프로그램을 실행하고, 문서 작성 후 저장을 실행했을 때의 과정을 프로세스의 상태변화 측면에서 설명하시오. 이때 커널모드/ 사용자모드의 측면에서의 설명도 포함해야 함.
A : 프로세서 안에서 저장 버튼을 누르면 프로그램은 running 상태가 되고 system call이 되어 blocking상태가 되고 커널모드로 이동하게 됩니다. 저장이 이루어지면 그 프로그램은 ready상태가 되고 blocking 상태에 있던 프로그램도 ready상태가 이루어 질 것입니다.

3. 워드 프로세스 실행시 입력 스레드, 출력 스레드, 저장 스레드가 동작한다. 만약, 해당 시스템에서 멀티 스레드가 지원되지 않는다고 가정할 경우, 이를 해결할 수 있는 방안을 설명하시오. (다양한 방법이 있을 수 있으므로 각자가 생각하는 방안을 제시하시오.)
A : 1. 스레드를 구현하는데 사용자 스레드 패키지를 구현해줍니다. 1-1. RTS: thread를 구현하거나 1-2. blocking 문제점을 제시해주면 됩니다.
2. 입력 프로세스, 출력 프로세스, 저장 프로세스를 각각 프로세스로 만들어서 방안을 제시해줍니다. 2-1. 자원 공유 방안이 필요하다. context switching에 대한 방안을 제시해줍니다. 2-2. 시스템 측면에선 관리만 하면 되기 때문에 상관없습니다.

4. 윈도우즈 탐색기 프로그램에서 새폴더를 생성하는 경우을 시스템 호출 측면에서 실행되는 전반적인 과정(매커니즘)을 자세히 설명하시오.
A : 특정 disk를 만드는 것이기 때문에 writing하는 정보가 필요합니다. 윈도우즈 탐색기 프로그램에서 명령이 실행되면 새폴더를 생성하는 시스템 호출이 일어납니다. 시스템 호출 관련 메커니즘을 제시합니다. 

5. 시분할 시스템에서 프로세스 테이블의 필요성에 대해 간략히 설명하고, 한 프로세스만 존재하여 종료할 때까지 시스템 전체를 활용하는 개인용 단일 시스템에서도 프로세스 테이블이 필요한지 설명하시오. 이 때, 메모리에는 해당 프로세스와 운영체제만 적재된다고 가정하고, 프로세스가 자원에 접근하는 경우에는 블록킹 시스템 호출을 사용한다.
A : 프로세스 테이블의 필요성이 필요한 이유를 설명합니다. 시분할 시스템에선 이전 상태의 프로세스의 상태를 알아야 하므로 프로세스 테이블이 필요합니다. 개인용 단일 시스템에서도 필요할 수도 있고 필요하지 않을 수도 있습니다. 프로세스가 하나만 존재하기 때문에 필요 없을 수도 있고 해당 프로세스와 운영체제만 적재된다면 운영체제도 하나의 프로그램이기 때문에 pcb(상태 저장 구조체)가 필요할 것입니다. 

프로그램(Program) 이란
사전적 의미
“어떤 작업을 위해 실행할 수 있는 파일”
프로세스(Process) 란
사전적 의미
“컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램”
메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
운영체제로부터 시스템 자원을 할당받는 작업의 단위
즉, 동적인 개념으로는 실행된 프로그램을 의미한다.
참고 할당받는 시스템 자원의 예
CPU 시간
운영되기 위해 필요한 주소 공간
Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역
스레드(Thread) 란
사전적 의미
“프로세스 내에서 실행되는 여러 흐름의 단위”
프로세스의 특정한 수행 경로

-개발자가 가져야 하는 습관
API 문서를 읽는 능력과 습관.
오류 트레이스를 읽는 능력과 습관.
개발자라면 언어나 라이브러리 등 새로운 기술을 접한다면 우선 해당 프로젝트의 기본 문서를 통해 개요를 파악하고, 무엇보다 API 문서를 통해 각 클래스나 메서드의 구체적인 의미나 용도를 이해할 줄 알아야 합니다.

유니온 파인드(Union Find) : 서로소 집합(Disjoint Set) 그리고 병합 찾기 집합(Merge Find Set)이라고도 불리며 여러 서로소 집합의 정보를 저장하고 있는 자료구조를 의미합니다.

* 자동차 업체 친구가 알려준 몇 가지 지식
MISRA C : https://ko.wikipedia.org/wiki/MISRA_C
ISO 26262 : https://www.onespin.com/safetycritical?utm_term=%2Biso26262&utm_campaign=Safety&utm_source=adwords&utm_medium=ppc&hsa_acc=5530023100&hsa_cam=7859270368&hsa_grp=82358437139&hsa_ad=394370051706&hsa_src=g&hsa_tgt=kwd-296653814363&hsa_kw=%2Biso26262&hsa_mt=b&hsa_net=adwords&hsa_ver=3&gclid=CjwKCAjwk6P2BRAIEiwAfVJ0rB9dbFDT0BMVPsReSjVbDLRbu34FNjE8fPwShL6wBLx6aqHbhmb81BoCgfwQAvD_BwE
A-spice : https://newbie-developer.tistory.com/15

웹 주니어 개발자가 되기 위한 Steps
1.HTML CSS
- 모든 태그, 용어를 다 외우는게 절대아님 구글링이 있음
- 구조와 원리를 이해하고 어떻게 사용하는지 이해하는것에 초점을맞춤
- 어지간한 웹사이트화면을 딱 보고 클론코딩할정도 까지 공부

2.바닐라JS
- 프레임워크를 일찍하지말고 가장기초이자 핵심인 바닐라js를 깊이공부 -> 깊이다져놓을수록 나중에 리엑트,뷰 등 프레임워크를 배우는것이 쉬워짐(시간을아낄수있음)
- "모달창 슬라이더 메뉴 드래그엔드랍" 등 웹의 인터렉티브한 부분을 바닐라js로 능숙하게 구현해낼수있을정도 까지 익혔으면, 다음 단계로 넘아가도됨(프레임웍, 백앤드 등)

3. 백엔드
- NodeJS든 뭐든, 언어는 아무거나 가능
- 백엔드에서 CRUD를 구현해 내기
- '생성 읽기 수정 삭제' 가 되는 시스템을 만들어낸다는 것은, 결국 HTML,CSS,JS, DB, 등등 을 다 할줄안다는 것
- 결국 '게시판'하나를 온전히 만들어 낼수있다는 것
=> 이정도까지 왔으면 사실상 취업가능, 이때부턴 일하면서 돈도벌고 실무를 배우며 성장하는게 좋음

4. 이후의 단게
- 각자의 길을 밟아가기

저장하는 파일로 txt는 쓰지말자...

이발사가 손님이 있을 때는 일하고 없을 때는 쉬는 것을 반복하는 일련의 과정을 비유로 들었다. 이발소에 이발사 한 명이 있다고 해 보자. 이 이발소에는 이발용 의자 하나가 있고, 대기실에는 많은 의자들이 있다. 이발사가 손님 한명의 머리를 다 깎고 나면, 손님을 보내고 다른 기다리는 손님이 있는지 확인하러 대기실로 간다. 만약 대기실에 손님이 있으면 이발용 의자로 데려와 머리를 깎는다. 대기실에 아무도 없으면 이발사는 자기 의자에 앉아서 잔다.

모든 손님은 이발소에 도착하면 이발사가 무엇을 하고 있는지 확인한다. 만약 자고 있으면 이발사를 깨우고 이발용 의자에 앉는다. 다른 사람을 이발하고 있으면 대기실로 간다. 대기실에 빈 의자가 있으면 거기에 앉고, 없으면 이발소를 떠난다. 단순하게 분석하면, 위 사례에서 더 이상 손님이 없으면 도착하는 모든 손님의 머리를 깎아주고, 다음 손님이 오기 전까지만 자는 이발사를 이용해 이발소가 제대로 운영되도록 해야 한다. 실제로, 위 사례에서 일반적인 스케줄링 (scheduling) 문제를 묘사할 수 있는 여러 가지 문제가 나타날 수 있다.

모든 문제들은 이발사와 손님들의 행동 시간 (대기실 확인하기, 이발사의 상태보기, 대기실 의자에 앉기 등의 시간)이 분명하지 않다는 것과 엮여 있다. 예를 들어, 손님이 이발소에 도착해서 이발사가 머리를 깎고 있으면 대기실로 간다. 그 손님이 대기실로 가고 있는 동안, 이발사가 머리를 다 깎고, 대기실을 확인한다. 손님이 아직 대기실에 도착하지 않아 그 곳에 아무도 없으면, 자기 자리로 돌아가 자 버린다. 이발사는 이제 다음 손님을 기다리고, 손님은 이발사를 기다리게 된다. 다른 예로, 대기실에 의자가 하나 남아 있을 때 두 손님이 동시에 이발소에 도착하는 경우가 있을 것이다. 이발사가 머리를 깎는 것을 보고 두 손님은 대기실로 가서 둘 다 하나 남은 의자를 차지하려고 한다. 잠자는 이발사 문제는 컴퓨터 과학의 선구자 중 한 사람인 에츠허르 데이크스트라가 만들었다고 보통 여겨져 왔다

경쟁 조건 : 둘 이상의 프로세스가 공유 메모리를 읽고 기록할 때, 마지막 결과는 어느 프로세스가 수행되었는가에 의존하는 상황
임계 구역 : 공유 메모리에 접근하는 프로그램 부분
상호 배제 조건 : 1. 어떤 두 프로세스도 동시에 임계 구역 안으로 들어갈 수 없다.
		2. CPU의 속도나 수에 대한 어떤 가정도 없다.
		3. 임계 구역 밖에서 수행되는 어떤 프로세스도 다른 프로세스를 블록시킬 수 없다.
		4. 어떤 프로세스도 임계 구역에 들어가기 위하여 영원히 기다리지 않는다.

Busy waiting을 이용한 상호 배제
인터럽트 끄기 / 락 변수 / 엄격한 교대 / Peterson의 해법 / TSL 명령
Sleep and Wakeup : 생산자 소비자 문제 

스케줄링 하는 시점 :
새 프로세스가 생성될 때, 프로세스가 종료될 때, 프로세스가 블록될 때, I/O interrupt가 발생할 때

 세그멘테이션(Segmentation)
  * 프로세스를 논리적 내용(=세그멘트)으로 잘라서 메모리에 배치
    : 프로세스는 세그멘트(segment)의 집합
  * 동일한 크기를 갖는 페이징과는 달리 메모리를 프로그램을 구성하는 메인루틴, 서브루틴(Sub-Routine), 프로시저(Procedure), 함수(Function) 또는 모듈(Module), 전역 변수, 스택(Stack) 등의 각각 다른 크기를 갖는 세그먼트로 나눔.
    : 각 세그먼트는 연관된 기능을 수행하는 하나의 모듈 프로그램임으로 논리적 구조화가 쉬움.
    : 각 세그먼트가 페이징처럼 메모리에서 서로 인접할 필요는 없음.
