Deadlock. 교착 상태.

운영체제 혹은 소프트웨어의 잘못된 자원 관리로 인하여 둘 이상의 프로세스(심하면 운영체제 자체도 포함해서)가 함께 멈추어 버리는 현상을 말한다. 위에 언급된 시에서는, 아기와 아빠는 서로 잠들지 못하는 교착(deadlock) 상태에 빠져 있다고 볼 수 있다. 인터럽트와 식사하는 철학자 문제 문서를 보는 것도 도움이 된다.

발전된 현대의 운영체제는 당연하게도 프로그램 미숙으로 인해 교착이 일어날 가능성을 어느 정도는 염두에 두고 있다. 해서, OS는 교차점에서 자원을 놓고 교착 상태에 빠지는 것을 가능하면 회피시켜버린다. 하지만 아무리 예측을 잘 하고 회피를 잘 해도 결국 답이 안 보이는 놈은 있는 법. 언젠가는 교착 상태에 빠져버리는 경우가 생길 수 있다.

이런 경우에는 프로그램 자체를 강제로 종료해버리는 수밖에 없는데, 교착에 빠진 프로그램 목록에 저놈들을 관리해야 할 운영체제가 끼어 있다면 그냥 망해버리는거다. 이런 일이 발생하기 쉬운 경우가 시스템 파일이나 다른 프로그램이 공유하는 파일을 건드리기 쉬운 프로그램 설치 과정인데, "프로그램을 설치할 때는 가능하면 다른 프로그램은 모두 꺼 주세요"라는 말이 나오는 이유가 이 놈 때문이다.

데드락의 주요 패턴으로 다중 쓰레드 프로그래밍 환경에서의 ABA 문제, AB/BA 문제 등이 있다. 락(뮤텍스 같은 다중 프로세스 동기화 장치)을 저 순서대로 짜면 첫 락에 진입하자마자 쓰레드가 바뀌는 경우(Context-Switching) 다른 쓰레드가 자꾸 얻으려고 시도하는데 이미 락은 걸려 있고, 풀어주진 않고, 그래서 무한 대기하는 현상을 칭한다.

해결법은 코드 순서를 조정해서 ABA는 AAB(= AB)로, AB/BA는 AB/AB로 바꾸어주면 된다. 만약 그게 안 된다면 락을 꼭 두 개를 써야 하는지 의문을 갖고 코드를 갈아엎던가, 처리 시간대를 다르게 바꾸어서 동시에 일어나지 않게 하는 식이다. 락을 하나로 합치는 방법도 있다.

데드락은 평소엔 별 문제가 없다가 가끔 쌩뚱맞게 일어나기 때문에 다중 쓰레드 프로그래밍의 주요 난점 중 하나이며, 이 때문에 락을 그냥 딱 하나만 사용하는 극단적인 경우도 생기게 된다. 물론 이러면 데드락은 없겠지만 CPU 활용도는 좀 떨어진다.

발생 조건 : 
1. mutual exclustion
2. hold and wait
3. no preeption
4. circular wait
* 실행 순서에 따라 deadlock이 생길수도 있습니다.

전략:
1. 문제를 단순히 무시
2. 탐지 및 회복
3. 자원할당을 통한 회피
4. 교착상태의 조건들 중 하나를 무효화시켜 예방

파일 시스템(file system, 문화어: 파일체계)은 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제를 가리키는 말이다.
파일 시스템은 일반적으로 크기가 일정한 블록들의 배열(섹터라고도 불리며 통상 512바이트, 1키비바이트, 2키비바이트 같은 2를 제곱수만큼의 크기를 갖는다)에 접근할 수 있는 자료 보관 장치 위에 생성되어 이러한 배열들을 조직함으로 파일이나 디렉터리를 만들며 어느 부분이 파일이고 어느 부분이 공백인지를 구분하기 위하여 각 배열에 표시를 해 둔다.
자료를 ‘클러스터’ 또는 ‘블록’이라고 불리는 일정한 단위(이것은 각 디스크 배열들에 대한 식별할 수 있는 번호를 제공하는데 통상 1부터 64까지가 쓰인다)에 새겨 넣는데 이것이 바로 파일 하나가 필요로 하는 디스크의 최소 공간이다.

C++ 에서 this란 자기 자신을 나타내는 말입니다.
즉 Class A a; 라는 객체가 있고 이 a의 주소값은 0x10 이라고 가정한다면
a 객체에서의 this는 0x10이라는 뜻입니다. 
즉 this는 자기 자신의 객체를 가르키는 것입니다. 따라서 this->num은 매개변수A(int num)를 가르키는 것이 아닌!! 맴버변수를 가리키는 것입니다.
*p는 출력하면 111이 나오죠. 이 것은 *p가 가르키는 값을 참조하기 때문입니다.(포인터의 참조 입니다.)

그럼 int &ref1 = *p는 int &ref1 = num_1; 으로 생각할 수 있는 겁니다.
int *(&ref2) = p; 는??? 이건 p가 가르키는 주소 값을 받는 상황임으로 당연히
포인터로 받아야 하지만 ref2는 참조값으로 저런식으로 받는것도 가능합니다.
단!! ref2는 참조변수지만 포인터로 전달 받기 때문에 별도의 포인터 주소 값을 지닙니다.
(마지막 출력 값을 보면 ref2의 주소값이 다른걸 알 수 있습니다.)


