2020=02-14

python return값에 함수 가능?

호이스팅은 끌어올려 졌다고 해서 얘기해줍니다.

Number a = function(){
   console.log('asdf');
}; 가능?

렉시컬은 정적이다라는 말이다.

[[Scope]] 라는 리스트 부분을 보면 알 수 있다.

실행 컨텍스트가 어떻게 이루어져 있는지 한번 확인해보기

라이브러리 프레임워크 프로그램 차이점 찾기

라이브러리 = 부품(기능과 구조)상자
모듈 = 부품(기능과 구조)
서브루틴 = 기능

라이브러리 [ library ] :
컴퓨터 이용의 효율화를 꾀하기 위해서 이용자가 필요에 따라서 사용하는 표준화된 프로그램 및 서브루틴의 모임을 말한다.
이들의 제공형태는 유저 프로그램의 속에서 서브루틴으로서 사용되는 서브모듈형과 일련의 처리가 라이브러리의 속에서 완결(完結)하는 패킷형으로 크게 나누어지는데 이것을 달리 프로그램 라이브러리라고도 한다.

서브루틴 [ Subroutine ] :
어떤 하나의 종합된 기능을 가지는 명령의 모임을 루틴이라고 하며, 이것에는 메인 루틴과 서브루틴이 있다. 메인 루틴이란 프로그램의 골격이 되는 루틴이고, 서브루틴이란 프로그램속에서 항상 반복 사용되는 부분적 프로그램이며, 그자신이 독립하여 사용되는 경우는 없고 메인 루틴과 결부되어서 기능을 다하는 일련의 프로그램을 말한다.

모듈 [ module ] :
⑴ 이미 알고 있는 특성을 갖는 기능 단위로서 부품 집합이고, 그대로 모듈」이라고 해석된다. 하드웨어에서는 메모리 보드나 각종 인터페이스 보드, 보조 입출력 장치(auxiliary input/output devices), 다중 중앙 처리 장치(multi-CPU)처럼 기능 단위로 되어 있기 때문에 용이하게 교환할 수 있도록 된 구조를 말한다. 소프트웨어에서도 하드웨어와 마찬가지로 하나로 일괄되어 다른 프로그램으로도 재이용(reusable)할 수 있는 형으로 되어 있는 것을 말하며, 복수(複數)의 모듈을 취급하기 쉽도록 하나로 일괄시킨 것을 라이브러리(library)라고 한다. 이와 같이 블록화, 모듈화하여 프로그램을 작성해두면 프로그램의 명세에 변경이 있어도 관계가 있는 모듈의 변경만으로 끝나고, 프로그램 개발의 생산성이 향상된다.
⑵ 컴 파일러(compiler)의 실행에 따라 얻어진 출력으로, 연결기(linker)의 입력이 되는 중간 프로그램을 목적 모듈(object module)이라고 한다. 
복수의 제어 세션(session)과 외부 심벌(external symbols)표로 구성되어 있다. 연결기의 실행에 따라 얻어진 실행 모듈을 로드 모듈(load module)이라고 한다.

[주] 수속(절차)이나 데이터의 선언으로부터 이루어진 언어 구성 요소이고, 다른 구성 요소와 상호적으로 작용할 수 있는 것. 예를 들면, Ada의 패키지, FORTRAN의 프로그램 단위, PL/I의 외부 절차.

C#프로그래밍

클래스<변수> : 컬렉션 프레임웤
모든 탬플릿은 <>를 지원해준다. 
약어, 용어는 외워라!
이벤트를 처리해주는 코드를 event handler
이벤트 동적 연결 : 이벤트 메서드를 연결해야 한다
C#은 포로그램의 강건성이 필요해서 exception handling을 구현했다.
상속에서는 부모는 모든 자식으로 캐스팅 가능
Button self(이벤트를 발생한 객체로 활용 된다) = (Button)sender
(this,Form1 자신을 생략)FormClosed += Form1_FormClosed로 파생된다.
interval 1000 = 1초

class의 멤버를 재사용하는 방법으로 상속
class의 계층구조를 효율적으로 이용하는 방법 중에 하나가 다향성
객체를 만들면 object를 상속 받고 기본 특징을 미리 상속 받는다.
다형성을 얻으려면 상속 구조를 가져야 한다.
부모 클래스의 객체이지만 자식 클래슬 캐스팅을 하면 자식 클래스를 만들어진다.
만약 쓰려면, 객체를 생성할 수 있어야 한다. 

생성자에는 기본 생성자와 파라미터 생성자가 존재한다.
public chlid(int a):base(a=>값을 넣어준다.){
}

정통집

메소드를 abstract하면 상속하면 구현해내야 한다. 
abstract는 virtual을 사용하지 않는다.
abstract는 메모리를 할당 받지 않는다.

인터페이스란?
하나의 시스템을 구성하는 2개의 구성 요소(하드웨어, 소프트웨어) 또는 2개의 시스템이 상호작용할 수 있도록 접속되는 경계(boundary), 이 경계에서 상호 접속하기 위한 하드웨어, 소프트웨어, 조건, 규약 등을 포괄적으로 가리키는 말
자바에서 인터페이스는 여러가지 역할로 사용한다.

개발자 사이의 코드 규약을 정한다.
여러 구현체에서 공통적인 부분을 추상화한다.(다형성)
먼저 자바에서 인터페이스의 기본 개념을 알아보자.

자바 인터페이스는 기본적으로 추상메서드의 모음이다. 추상메서드는 아래와 같이 구현부가 없는 메서드를 말한다.
구현부가 없으므로 인터페이스를 만든다면 반드시 구현하는 클래스를 만들어야 하며, 인터페이스를 구현하기로 한 클래스는 반드시 인터페이스에 명시되어 있는 추상메서드들을 모두 구현해야 한다. 만약 이를 구현하지 않으면 컴파일 에러가 발생한다.
인터페이스는 구현과 상속을 모두 할 수 있다.

인터페이스를 사용하는 구체 클래스는 해당 인터페이스를 구현해야한다.
인터페이스 사이에는 상속을 할 수 있다.
인터페이스를 사용하면 다중 상속이 가능하다. 인터페이스 사이에서도, 구체 클래스에서도 여러 인터페이스를 구현 및 상속할 수 있다.

.4 프로세스간 통신(IPC, InterProcess Communication)
 1) 프로세스간 통신(IPC)란?
   - 프로세스들 간에 데이터 및 정보를 주고받기 위한 메커니즘을 말한다.
   - 커널에서 IPC를 위한 도구를 제공하며, 시스템 콜의 형태로 프로세스에게 제공된다.

 2) 프로세스간 통신의 필요성
   - 운영체제 내에서 실행되는 프로세스들은 독립적(independent)이거나 협력적(cooperative)인 프로세스들 일 수 있다.
   - 프로세스 협력 모델(cooperating process model)을 구현하기 위해 IPC가 반드시 필요하다.
  (1) 독립적인 프로세스(independent process)
   - 시스템에서 실행 중인 다른 프로세스들에게 영향을 주거나 받지 않는 프로세스
  (2) 협력적인 프로세스(cooperative process)
   - 시스템에서 실행 중인 다른 프로세스들에게 영향을 주거나 받는 프로세스
* 프로세스간 통신(IPC)에는 크게 두 가지 모델이 있다.
 1) 공유 메모리(Shared Memory) 모델
 2) 메시지 전달(Message Passing) 모델
3.4.1 공유 메모리(Shared Memory)
 1) 공유 메모리 모델의 특징
   - 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며, 공유한 메모리 영역에 읽기/쓰기를 통해서 통신을 수행한다. (Read and Write)
   - 공유 메모리가 설정되면, 그 이후의 통신은 커널의 관여 없이 진행 가능하다.

 2) 공유 메모리 모델의 장점
   - 커널의 관여 없이 메모리를 직접 사용하여 IPC 속도가 빠르다.
   - 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.

 3) 공유 메모리 모델의 단점
   - 구현하기 어렵다는 단점이 있다.

 4) 컨텍스트 스위칭 관점
   - 공유 메모리 모델에서의 IPC는 해당 프로세스가 CPU를 사용하는 행위이다. 
   - 즉, IPC를 많이 한다고 컨텍스트 스위칭 많이 일어나지 않는다.

 5) 동기화 관점
   - 메모리 영역에 대한 동시적인 접근을 제어하기 위한 방법이 필요하다.
   - 커널이 동기화를 제공하지 않으며, 부가적인 방법이 필요하다.
   - 접근 제어 방식은 locking이나 세마포어(semaphore) 등이 있다.

 6) 공유 메모리 모델의 활용의 예 : 데이터베이스
 7) 공유 메모리 모델의 구현 IPC : 공유 메모리(Shared Memory)
   - 모델과 구현의 이름이 같다.

공유 메모리
 8) 버퍼(Buffer)
   - 협력적인 프로세스의 예로, 생산자-소비자 문제를 들 수 있다.
   - 생산자-소비자 문제에 대한 하나의 해결책은, 공유 메모리(Shared memory)를 사용하는 것이며, 이 때 생산자가 정보를 채워 넣을 수 있고 소비자가 정보를 소모할 수 있는 버퍼(Buffer)가 반드시 사용 가능해야 한다.
* 버퍼는 크기에 따라 세 가지 유형으로 나눠볼 수 있다.
1) Zero capacity
- no buffering
- 저장할 수 있는 메시지의 개수는 0개이다.
- 송신자는 수신자가 메시지를 받을 때까지 대기(block)해야 한다.

2) 유한 버퍼(Bounded capacity)
- automatic buffering
- 저장할 수 있는 메시지의 개수는 n개이다.
- 버퍼가 가득 차 있지 않을 때에는, 송신자는 메시지를 보내고 대기할 필요가 없다.
- 버퍼가 가득 차 있는 경우라면, 송신자는 버퍼에 빈 공간이 생길 때까지 대기해야 한다.

3) 무한 버퍼(Unbounded capacity)
- automatic buffering
- 저장할 수 있는 메시지의 개수가 무한 개이다.
- 버퍼가 가득 찰 일이 없기 때문에, 모든 경우에 송신자는 대기할 필요가 없다.
3.4.2 메시지 전달(message passing)
 1) 메시지 전달 모델의 특징
   - 커널을 경유하여 고정길이 메시지, 가변길이 메시지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링한다. (Send and Receive)
   - 프로세스간 메모리 공유 없이 동작이 가능하다.

 2) 메시지 전달 모델의 장점
   - 구현하기에 간단하여 사용하기 편리하다.

 3) 메시지 전달 모델의 단점
   - 커널을 경유하므로, 속도가 느리다.

 4) 컨텍스트 스위칭 관점
   - 메시지 전달 모델에서의 IPC는 해당 프로세스 입장에서 일종의 입출력(I/O)로 볼 수 있다.
   - 즉, IPC를 하면 할수록 컨텍스트 스위칭이 많이 일어난다.
   => 예를 들어, send하고 상대방이 받을 때까지 기다려야 하며, 이 때 컨텍스트 스위칭이 발생한다.
   => 마찬가지로, receive하면 상대방이 보낼 때까지 기다려야 하며, 이 때 컨텍스트 스위칭이 발생한다.

 5) 동기화 관점
   - send와 receive와 같은 연산에 대해서는 커널이 동기화를 제공한다.
   - send와 receive를 수행할 때에 프로그램은 동기화에 대한 고려 없이 사용할 수 있다.
 
 6) 메시지 전달 모델 활용의 예 : 서버-클라이언트 방식의 통신
 7) 메시지 전달 모델의 구현 IPC : PIPE, Message Queue, Socket , Signal, ...
 
 1. 병렬성 측면에서 멀티프로세싱과 멀티프로세싱을 설명하고, 멀티프로세싱일 경우 각 프로세서 내에서의 메모리의 효율적인 운영방안에 대해 제시하시오.
A : 하나의 메모리 안에 여러 프로그램을 가지고 있고 의사병렬성을 가지고 있습니다. 멀티 프로세싱은 여러개의 멀티 프로세서가 존재하는 것을 의미합니다. 서로 다른 프로세서가 하나의 프로그램을 사용할 수 있기 때문에 공유 방안이 필요하고, 서로 다른 프로세서가 서로 다른 프로그램을 실행시키면 보호 방안이 필요합니다.

2. 워드 프로세스 프로그램을 실행하고, 문서 작성 후 저장을 실행했을 때의 과정을 프로세스의 상태변화 측면에서 설명하시오. 이때 커널모드/ 사용자모드의 측면에서의 설명도 포함해야 함.
A : 프로세서 안에서 저장 버튼을 누르면 프로그램은 running 상태가 되고 system call이 되어 blocking상태가 되고 커널모드로 이동하게 됩니다. 저장이 이루어지면 그 프로그램은 ready상태가 되고 blocking 상태에 있던 프로그램도 ready상태가 이루어 질 것입니다.

3. 워드 프로세스 실행시 입력 스레드, 출력 스레드, 저장 스레드가 동작한다. 만약, 해당 시스템에서 멀티 스레드가 지원되지 않는다고 가정할 경우, 이를 해결할 수 있는 방안을 설명하시오. (다양한 방법이 있을 수 있으므로 각자가 생각하는 방안을 제시하시오.)
A : 1. 스레드를 구현하는데 사용자 스레드 패키지를 구현해줍니다. 1-1. RTS: thread를 구현하거나 1-2. blocking 문제점을 제시해주면 됩니다.
2. 입력 프로세스, 출력 프로세스, 저장 프로세스를 각각 프로세스로 만들어서 방안을 제시해줍니다. 2-1. 자원 공유 방안이 필요하다. context switching에 대한 방안을 제시해줍니다. 2-2. 시스템 측면에선 관리만 하면 되기 때문에 상관없습니다.

4. 윈도우즈 탐색기 프로그램에서 새폴더를 생성하는 경우을 시스템 호출 측면에서 실행되는 전반적인 과정(매커니즘)을 자세히 설명하시오.
A : 특정 disk를 만드는 것이기 때문에 writing하는 정보가 필요합니다. 윈도우즈 탐색기 프로그램에서 명령이 실행되면 새폴더를 생성하는 시스템 호출이 일어납니다. 시스템 호출 관련 메커니즘을 제시합니다. 

5. 시분할 시스템에서 프로세스 테이블의 필요성에 대해 간략히 설명하고, 한 프로세스만 존재하여 종료할 때까지 시스템 전체를 활용하는 개인용 단일 시스템에서도 프로세스 테이블이 필요한지 설명하시오. 이 때, 메모리에는 해당 프로세스와 운영체제만 적재된다고 가정하고, 프로세스가 자원에 접근하는 경우에는 블록킹 시스템 호출을 사용한다.
A : 프로세스 테이블의 필요성이 필요한 이유를 설명합니다. 시분할 시스템에선 이전 상태의 프로세스의 상태를 알아야 하므로 프로세스 테이블이 필요합니다. 개인용 단일 시스템에서도 필요할 수도 있고 필요하지 않을 수도 있습니다. 프로세스가 하나만 존재하기 때문에 필요 없을 수도 있고 해당 프로세스와 운영체제만 적재된다면 운영체제도 하나의 프로그램이기 때문에 pcb(상태 저장 구조체)가 필요할 것입니다. 

프로그램(Program) 이란
사전적 의미
“어떤 작업을 위해 실행할 수 있는 파일”
프로세스(Process) 란
사전적 의미
“컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램”
메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
운영체제로부터 시스템 자원을 할당받는 작업의 단위
즉, 동적인 개념으로는 실행된 프로그램을 의미한다.
참고 할당받는 시스템 자원의 예
CPU 시간
운영되기 위해 필요한 주소 공간
Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역
스레드(Thread) 란
사전적 의미
“프로세스 내에서 실행되는 여러 흐름의 단위”
프로세스의 특정한 수행 경로

-개발자가 가져야 하는 습관
API 문서를 읽는 능력과 습관.
오류 트레이스를 읽는 능력과 습관.
개발자라면 언어나 라이브러리 등 새로운 기술을 접한다면 우선 해당 프로젝트의 기본 문서를 통해 개요를 파악하고, 무엇보다 API 문서를 통해 각 클래스나 메서드의 구체적인 의미나 용도를 이해할 줄 알아야 합니다.

유니온 파인드(Union Find) : 서로소 집합(Disjoint Set) 그리고 병합 찾기 집합(Merge Find Set)이라고도 불리며 여러 서로소 집합의 정보를 저장하고 있는 자료구조를 의미합니다.

* 자동차 업체 친구가 알려준 몇 가지 지식
MISRA C : https://ko.wikipedia.org/wiki/MISRA_C
ISO 26262 : https://www.onespin.com/safetycritical?utm_term=%2Biso26262&utm_campaign=Safety&utm_source=adwords&utm_medium=ppc&hsa_acc=5530023100&hsa_cam=7859270368&hsa_grp=82358437139&hsa_ad=394370051706&hsa_src=g&hsa_tgt=kwd-296653814363&hsa_kw=%2Biso26262&hsa_mt=b&hsa_net=adwords&hsa_ver=3&gclid=CjwKCAjwk6P2BRAIEiwAfVJ0rB9dbFDT0BMVPsReSjVbDLRbu34FNjE8fPwShL6wBLx6aqHbhmb81BoCgfwQAvD_BwE
A-spice : https://newbie-developer.tistory.com/15
